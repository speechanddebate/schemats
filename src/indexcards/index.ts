/**
 * Generated by orval v8.4.1 üç∫
 * Do not edit manually.
 * IndexCards API
 * Tabroom.com data & operational API
 * OpenAPI spec version: 1.2.0
 */
import { createMutation, createQuery } from '@tanstack/svelte-query';
import type {
	CreateMutationOptions,
	CreateMutationResult,
	CreateQueryOptions,
	CreateQueryResult,
	DataTag,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
} from '@tanstack/svelte-query';

import type {
	ErrorResponseResponse,
	GetParadigmByPersonId200,
	LoginRequest,
	NotFoundResponse,
	RegisterRequest,
	SearchParadigms200Item,
	SearchParadigmsParams,
	TournInvite,
	UnauthorizedResponse,
} from './schemas';

import { orvalMutator } from './utils';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx =
	| 400
	| 401
	| 402
	| 403
	| 404
	| 405
	| 406
	| 407
	| 408
	| 409
	| 410
	| 411
	| 412
	| 413
	| 414
	| 415
	| 416
	| 417
	| 418
	| 419
	| 420
	| 421
	| 422
	| 423
	| 424
	| 426
	| 428
	| 429
	| 431
	| 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes =
	| HTTPStatusCode1xx
	| HTTPStatusCode2xx
	| HTTPStatusCode3xx
	| HTTPStatusCode4xx
	| HTTPStatusCode5xx;

/**
 * Logs in a user and creates a session.
 * @summary Login
 */
export type loginResponse200 = {
	data: void;
	status: 200;
};

export type loginResponse401 = {
	data: UnauthorizedResponse;
	status: 401;
};

export type loginResponse500 = {
	data: ErrorResponseResponse;
	status: 500;
};

export type loginResponseSuccess = loginResponse200 & {
	headers: Headers;
};
export type loginResponseError = (loginResponse401 | loginResponse500) & {
	headers: Headers;
};

export type loginResponse = loginResponseSuccess | loginResponseError;

export const getLoginUrl = () => {
	return `/v1/auth/login`;
};

export const login = async (
	loginRequest: LoginRequest,
	options?: RequestInit,
): Promise<loginResponse> => {
	return orvalMutator<loginResponse>(getLoginUrl(), {
		credentials: 'include',
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(loginRequest),
	});
};

export const getLoginMutationOptions = <
	TError = UnauthorizedResponse | ErrorResponseResponse,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof login>>,
		TError,
		{ data: LoginRequest },
		TContext
	>;
	request?: SecondParameter<typeof orvalMutator>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: LoginRequest },
	TContext
> => {
	const mutationKey = ['login'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			'mutationKey' in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof login>>,
		{ data: LoginRequest }
	> = (props) => {
		const { data } = props ?? {};

		return login(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
	Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = LoginRequest;
export type LoginMutationError = UnauthorizedResponse | ErrorResponseResponse;

/**
 * @summary Login
 */
export const createLogin = <
	TError = UnauthorizedResponse | ErrorResponseResponse,
	TContext = unknown,
>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof login>>,
			TError,
			{ data: LoginRequest },
			TContext
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
	queryClient?: () => QueryClient,
): CreateMutationResult<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: LoginRequest },
	TContext
> => {
	return createMutation(
		() => ({ ...getLoginMutationOptions(options?.()) }),
		queryClient,
	);
};

/**
 * Logs out the current user and invalidates the session.
 * @summary Logout
 */
export type logoutResponse200 = {
	data: void;
	status: 200;
};

export type logoutResponse401 = {
	data: UnauthorizedResponse;
	status: 401;
};

export type logoutResponse500 = {
	data: ErrorResponseResponse;
	status: 500;
};

export type logoutResponseSuccess = logoutResponse200 & {
	headers: Headers;
};
export type logoutResponseError = (logoutResponse401 | logoutResponse500) & {
	headers: Headers;
};

export type logoutResponse = logoutResponseSuccess | logoutResponseError;

export const getLogoutUrl = () => {
	return `/v1/auth/logout`;
};

export const logout = async (
	options?: RequestInit,
): Promise<logoutResponse> => {
	return orvalMutator<logoutResponse>(getLogoutUrl(), {
		credentials: 'include',
		...options,
		method: 'POST',
	});
};

export const getLogoutMutationOptions = <
	TError = UnauthorizedResponse | ErrorResponseResponse,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof logout>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof orvalMutator>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof logout>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ['logout'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			'mutationKey' in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof logout>>,
		void
	> = () => {
		return logout(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<
	Awaited<ReturnType<typeof logout>>
>;

export type LogoutMutationError = UnauthorizedResponse | ErrorResponseResponse;

/**
 * @summary Logout
 */
export const createLogout = <
	TError = UnauthorizedResponse | ErrorResponseResponse,
	TContext = unknown,
>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof logout>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
	queryClient?: () => QueryClient,
): CreateMutationResult<
	Awaited<ReturnType<typeof logout>>,
	TError,
	void,
	TContext
> => {
	return createMutation(
		() => ({ ...getLogoutMutationOptions(options?.()) }),
		queryClient,
	);
};

/**
 * Registers a new user.
 * @summary Register
 */
export type registerResponse200 = {
	data: void;
	status: 200;
};

export type registerResponse401 = {
	data: UnauthorizedResponse;
	status: 401;
};

export type registerResponse500 = {
	data: ErrorResponseResponse;
	status: 500;
};

export type registerResponseSuccess = registerResponse200 & {
	headers: Headers;
};
export type registerResponseError = (
	| registerResponse401
	| registerResponse500
) & {
	headers: Headers;
};

export type registerResponse = registerResponseSuccess | registerResponseError;

export const getRegisterUrl = () => {
	return `/v1/auth/register`;
};

export const register = async (
	registerRequest: RegisterRequest,
	options?: RequestInit,
): Promise<registerResponse> => {
	return orvalMutator<registerResponse>(getRegisterUrl(), {
		credentials: 'include',
		...options,
		method: 'POST',
		headers: { 'Content-Type': 'application/json', ...options?.headers },
		body: JSON.stringify(registerRequest),
	});
};

export const getRegisterMutationOptions = <
	TError = UnauthorizedResponse | ErrorResponseResponse,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof register>>,
		TError,
		{ data: RegisterRequest },
		TContext
	>;
	request?: SecondParameter<typeof orvalMutator>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: RegisterRequest },
	TContext
> => {
	const mutationKey = ['register'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			'mutationKey' in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof register>>,
		{ data: RegisterRequest }
	> = (props) => {
		const { data } = props ?? {};

		return register(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<
	Awaited<ReturnType<typeof register>>
>;
export type RegisterMutationBody = RegisterRequest;
export type RegisterMutationError =
	| UnauthorizedResponse
	| ErrorResponseResponse;

/**
 * @summary Register
 */
export const createRegister = <
	TError = UnauthorizedResponse | ErrorResponseResponse,
	TContext = unknown,
>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof register>>,
			TError,
			{ data: RegisterRequest },
			TContext
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
	queryClient?: () => QueryClient,
): CreateMutationResult<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: RegisterRequest },
	TContext
> => {
	return createMutation(
		() => ({ ...getRegisterMutationOptions(options?.()) }),
		queryClient,
	);
};

/**
 * Retrieve a public invite for a specific tournament, including pages, files, events, and contacts.
 * @summary Get Tournament Invite
 */
export type getTournInviteResponse200 = {
	data: TournInvite;
	status: 200;
};

export type getTournInviteResponse401 = {
	data: UnauthorizedResponse;
	status: 401;
};

export type getTournInviteResponse404 = {
	data: NotFoundResponse;
	status: 404;
};

export type getTournInviteResponse500 = {
	data: ErrorResponseResponse;
	status: 500;
};

export type getTournInviteResponseDefault = {
	data: ErrorResponseResponse;
	status: Exclude<HTTPStatusCodes, 200 | 401 | 404 | 500>;
};

export type getTournInviteResponseSuccess = getTournInviteResponse200 & {
	headers: Headers;
};
export type getTournInviteResponseError = (
	| getTournInviteResponse401
	| getTournInviteResponse404
	| getTournInviteResponse500
	| getTournInviteResponseDefault
) & {
	headers: Headers;
};

export type getTournInviteResponse =
	| getTournInviteResponseSuccess
	| getTournInviteResponseError;

export const getGetTournInviteUrl = (tournId: string) => {
	return `/v1/rest/tourns/${tournId}/invite`;
};

export const getTournInvite = async (
	tournId: string,
	options?: RequestInit,
): Promise<getTournInviteResponse> => {
	return orvalMutator<getTournInviteResponse>(getGetTournInviteUrl(tournId), {
		credentials: 'include',
		...options,
		method: 'GET',
	});
};

export const getGetTournInviteQueryKey = (tournId: string) => {
	return [`/v1/rest/tourns/${tournId}/invite`] as const;
};

export const getGetTournInviteQueryOptions = <
	TData = Awaited<ReturnType<typeof getTournInvite>>,
	TError = UnauthorizedResponse | NotFoundResponse | ErrorResponseResponse,
>(
	tournId: string,
	options?: {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getTournInvite>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetTournInviteQueryKey(tournId);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getTournInvite>>
	> = ({ signal }) => getTournInvite(tournId, { signal, ...requestOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!tournId,
		...queryOptions,
	} as CreateQueryOptions<
		Awaited<ReturnType<typeof getTournInvite>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTournInviteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTournInvite>>
>;
export type GetTournInviteQueryError =
	| UnauthorizedResponse
	| NotFoundResponse
	| ErrorResponseResponse;

/**
 * @summary Get Tournament Invite
 */

export function createGetTournInvite<
	TData = Awaited<ReturnType<typeof getTournInvite>>,
	TError = UnauthorizedResponse | NotFoundResponse | ErrorResponseResponse,
>(
	tournId: () => string,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getTournInvite>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
	queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const query = createQuery(
		() => getGetTournInviteQueryOptions(tournId(), options?.()),
		queryClient,
	) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return query;
}

/**
 * GET /rest/paradigms is undocumented. Need to add .openapi to handler
 * @summary Search paradigms
 */
export type searchParadigmsResponse200 = {
	data: SearchParadigms200Item[];
	status: 200;
};

export type searchParadigmsResponse401 = {
	data: UnauthorizedResponse;
	status: 401;
};

export type searchParadigmsResponse500 = {
	data: ErrorResponseResponse;
	status: 500;
};

export type searchParadigmsResponseDefault = {
	data: ErrorResponseResponse;
	status: Exclude<HTTPStatusCodes, 200 | 401 | 500>;
};

export type searchParadigmsResponseSuccess = searchParadigmsResponse200 & {
	headers: Headers;
};
export type searchParadigmsResponseError = (
	| searchParadigmsResponse401
	| searchParadigmsResponse500
	| searchParadigmsResponseDefault
) & {
	headers: Headers;
};

export type searchParadigmsResponse =
	| searchParadigmsResponseSuccess
	| searchParadigmsResponseError;

export const getSearchParadigmsUrl = (params: SearchParadigmsParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(
				key,
				value === null ? 'null' : value.toString(),
			);
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/v1/rest/paradigms?${stringifiedParams}`
		: `/v1/rest/paradigms`;
};

export const searchParadigms = async (
	params: SearchParadigmsParams,
	options?: RequestInit,
): Promise<searchParadigmsResponse> => {
	return orvalMutator<searchParadigmsResponse>(
		getSearchParadigmsUrl(params),
		{
			credentials: 'include',
			...options,
			method: 'GET',
		},
	);
};

export const getSearchParadigmsQueryKey = (params?: SearchParadigmsParams) => {
	return [`/v1/rest/paradigms`, ...(params ? [params] : [])] as const;
};

export const getSearchParadigmsQueryOptions = <
	TData = Awaited<ReturnType<typeof searchParadigms>>,
	TError = UnauthorizedResponse | ErrorResponseResponse,
>(
	params: SearchParadigmsParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof searchParadigms>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getSearchParadigmsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof searchParadigms>>
	> = ({ signal }) => searchParadigms(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof searchParadigms>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchParadigmsQueryResult = NonNullable<
	Awaited<ReturnType<typeof searchParadigms>>
>;
export type SearchParadigmsQueryError =
	| UnauthorizedResponse
	| ErrorResponseResponse;

/**
 * @summary Search paradigms
 */

export function createSearchParadigms<
	TData = Awaited<ReturnType<typeof searchParadigms>>,
	TError = UnauthorizedResponse | ErrorResponseResponse,
>(
	params: () => SearchParadigmsParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof searchParadigms>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
	queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const query = createQuery(
		() => getSearchParadigmsQueryOptions(params(), options?.()),
		queryClient,
	) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return query;
}

/**
 * GET /rest/paradigms/{personId} is undocumented. Need to add .openapi to handler
 * @summary Get paradigm details by person ID
 */
export type getParadigmByPersonIdResponse200 = {
	data: GetParadigmByPersonId200;
	status: 200;
};

export type getParadigmByPersonIdResponse401 = {
	data: UnauthorizedResponse;
	status: 401;
};

export type getParadigmByPersonIdResponse404 = {
	data: NotFoundResponse;
	status: 404;
};

export type getParadigmByPersonIdResponse500 = {
	data: ErrorResponseResponse;
	status: 500;
};

export type getParadigmByPersonIdResponseDefault = {
	data: ErrorResponseResponse;
	status: Exclude<HTTPStatusCodes, 200 | 401 | 404 | 500>;
};

export type getParadigmByPersonIdResponseSuccess =
	getParadigmByPersonIdResponse200 & {
		headers: Headers;
	};
export type getParadigmByPersonIdResponseError = (
	| getParadigmByPersonIdResponse401
	| getParadigmByPersonIdResponse404
	| getParadigmByPersonIdResponse500
	| getParadigmByPersonIdResponseDefault
) & {
	headers: Headers;
};

export type getParadigmByPersonIdResponse =
	| getParadigmByPersonIdResponseSuccess
	| getParadigmByPersonIdResponseError;

export const getGetParadigmByPersonIdUrl = (personId: number) => {
	return `/v1/rest/paradigms/${personId}`;
};

export const getParadigmByPersonId = async (
	personId: number,
	options?: RequestInit,
): Promise<getParadigmByPersonIdResponse> => {
	return orvalMutator<getParadigmByPersonIdResponse>(
		getGetParadigmByPersonIdUrl(personId),
		{
			credentials: 'include',
			...options,
			method: 'GET',
		},
	);
};

export const getGetParadigmByPersonIdQueryKey = (personId: number) => {
	return [`/v1/rest/paradigms/${personId}`] as const;
};

export const getGetParadigmByPersonIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getParadigmByPersonId>>,
	TError = UnauthorizedResponse | NotFoundResponse | ErrorResponseResponse,
>(
	personId: number,
	options?: {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getParadigmByPersonId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetParadigmByPersonIdQueryKey(personId);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getParadigmByPersonId>>
	> = ({ signal }) =>
		getParadigmByPersonId(personId, { signal, ...requestOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!personId,
		...queryOptions,
	} as CreateQueryOptions<
		Awaited<ReturnType<typeof getParadigmByPersonId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetParadigmByPersonIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getParadigmByPersonId>>
>;
export type GetParadigmByPersonIdQueryError =
	| UnauthorizedResponse
	| NotFoundResponse
	| ErrorResponseResponse;

/**
 * @summary Get paradigm details by person ID
 */

export function createGetParadigmByPersonId<
	TData = Awaited<ReturnType<typeof getParadigmByPersonId>>,
	TError = UnauthorizedResponse | NotFoundResponse | ErrorResponseResponse,
>(
	personId: () => number,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof getParadigmByPersonId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof orvalMutator>;
	},
	queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const query = createQuery(
		() => getGetParadigmByPersonIdQueryOptions(personId(), options?.()),
		queryClient,
	) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	return query;
}
